<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS清除浮动</title>
    <url>/2020/10/21/CSS%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</url>
    <content><![CDATA[<h3 id="什么是CSS清除浮动？"><a href="#什么是CSS清除浮动？" class="headerlink" title="什么是CSS清除浮动？"></a><strong>什么是CSS清除浮动？</strong></h3><p>在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。</p>
<a id="more"></a>

<p>引用W3C的例子，news容器没有包围浮动的元素。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.news</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: gray;</span><br><span class="line">  <span class="attribute">border</span>: solid <span class="number">1px</span> black;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.news</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.news</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;news&quot;&gt;</span><br><span class="line">&lt;img src=&quot;news-pic.jpg&quot; /&gt;</span><br><span class="line">&lt;<span class="selector-tag">p</span>&gt;<span class="selector-tag">some</span> <span class="selector-tag">text</span>&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>



<h3 id="清除浮动方法"><a href="#清除浮动方法" class="headerlink" title="清除浮动方法"></a><strong>清除浮动方法</strong></h3><h4 id="方法一：使用带clear属性的空元素"><a href="#方法一：使用带clear属性的空元素" class="headerlink" title="方法一：使用带clear属性的空元素"></a><strong>方法一：使用带clear属性的空元素</strong></h4><p>在浮动元素后使用一个空元素如<div class="clear"></div>，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。亦可使用<br class="clear" />或<hr class="clear" />来进行清理。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.news</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: gray;</span><br><span class="line">  <span class="attribute">border</span>: solid <span class="number">1px</span> black;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.news</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.news</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clear</span> &#123;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;news&quot;&gt;</span><br><span class="line">&lt;img src=&quot;news-pic.jpg&quot; /&gt;</span><br><span class="line">&lt;<span class="selector-tag">p</span>&gt;<span class="selector-tag">some</span> <span class="selector-tag">text</span>&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>

<p>优点：简单，代码少，浏览器兼容性好。</p>
<p>缺点：需要添加大量无语义的html元素，代码不够优雅，后期不容易维护。</p>
<h4 id="方法二：使用CSS的overflow属性"><a href="#方法二：使用CSS的overflow属性" class="headerlink" title="方法二：使用CSS的overflow属性"></a><strong>方法二：使用CSS的overflow属性</strong></h4><p>给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。</p>
<p>在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.news</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: gray;</span><br><span class="line">  <span class="attribute">border</span>: solid <span class="number">1px</span> black;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">*zoom</span>: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.news</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.news</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;news&quot;&gt;</span><br><span class="line">&lt;img src=&quot;news-pic.jpg&quot; /&gt;</span><br><span class="line">&lt;<span class="selector-tag">p</span>&gt;<span class="selector-tag">some</span> <span class="selector-tag">text</span>&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>

<h4 id="方法三：给浮动的元素的容器添加浮动"><a href="#方法三：给浮动的元素的容器添加浮动" class="headerlink" title="方法三：给浮动的元素的容器添加浮动"></a><strong>方法三：给浮动的元素的容器添加浮动</strong></h4><p>给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，不推荐使用。</p>
<h4 id="方法四：使用邻接元素处理"><a href="#方法四：使用邻接元素处理" class="headerlink" title="方法四：使用邻接元素处理"></a><strong>方法四：使用邻接元素处理</strong></h4><p>什么都不做，给浮动元素后面的元素添加clear属性。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.news</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: gray;</span><br><span class="line">  <span class="attribute">border</span>: solid <span class="number">1px</span> black;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.news</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.news</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">  <span class="attribute">clear</span>:both;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;news&quot;&gt;</span><br><span class="line">&lt;img src=&quot;news-pic.jpg&quot; /&gt;</span><br><span class="line">&lt;<span class="selector-tag">p</span>&gt;<span class="selector-tag">some</span> <span class="selector-tag">text</span>&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>

<h4 id="方法五：使用CSS的-after伪元素"><a href="#方法五：使用CSS的-after伪元素" class="headerlink" title="方法五：使用CSS的:after伪元素"></a><strong>方法五：使用CSS的:after伪元素</strong></h4><p>结合 :after 伪元素（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout。</p>
<p>给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.news</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: gray;</span><br><span class="line">  <span class="attribute">border</span>: solid <span class="number">1px</span> black;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.news</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.news</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;020&quot;</span>; </span><br><span class="line">  <span class="attribute">display</span>: block; </span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>; </span><br><span class="line">  <span class="attribute">clear</span>: both; </span><br><span class="line">  <span class="attribute">visibility</span>: hidden;  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  <span class="comment">/* 触发 hasLayout */</span> </span><br><span class="line">  <span class="attribute">zoom</span>: <span class="number">1</span>; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;news clearfix&quot;&gt;</span><br><span class="line">&lt;img src=&quot;news-pic.jpg&quot; /&gt;</span><br><span class="line">&lt;<span class="selector-tag">p</span>&gt;<span class="selector-tag">some</span> <span class="selector-tag">text</span>&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>

<p>通过CSS伪元素在容器的内部元素最后添加了一个看不见的空格”020”或点”.”，并且赋予clear属性来清除浮动。需要注意的是为了IE6和IE7浏览器，要给clearfix这个class添加一条zoom:1;触发haslayout。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>通过上面的例子，我们不难发现清除浮动的方法可以分成两类：</p>
<p>一是利用 clear 属性，包括在浮动元素末尾添加一个带有 clear: both 属性的空 div 来闭合元素，其实利用 :after 伪元素的方法也是在元素末尾添加一个内容为一个点并带有 clear: both 属性的元素实现的。</p>
<p>二是触发浮动元素父元素的 BFC (Block Formatting Contexts, 块级格式化上下文)，使到该父元素可以包含浮动元素。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript数据类型</title>
    <url>/2020/11/12/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>JavaScript中关于类型的值分为<strong>基本数据类型</strong>和<strong>复杂数据类型</strong>。</p>
<a id="more"></a>

<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">js 一共有六种基本数据类型，分别是 Undefined、Null、Boolean、Number、String，还有在 ES6 中新增的 Symbol 和 ES10 中新增的 BigInt 类型。</span><br><span class="line">Symbol 代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。</span><br><span class="line">BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</span><br></pre></td></tr></table></figure>

<h2 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复杂数据类型指的是 Object 类型，所有其他的如 Array、Date 等数据类型都可以理解为 Object 类型的子类。</span><br></pre></td></tr></table></figure>

<h2 id="区别是什么？"><a href="#区别是什么？" class="headerlink" title="区别是什么？"></a>区别是什么？</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">两种类型的区别是：存储位置不同。</span><br><span class="line">原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</span><br><span class="line"></span><br><span class="line">引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在</span><br><span class="line">栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实</span><br><span class="line">体。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>CSS盒模型</title>
    <url>/2020/10/08/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><p>盒模型有两种， IE 怪异盒子模型、W3C 标准盒子模型；</p>
<p>盒模型是由： 内容(content)、内边距(padding)、边框(border)、外边距(margin) 组成的。</p>
<p>标准模型的宽高是指的 content 区宽高；<br>IE 盒模型的宽高是指的 content+padding+border 的宽高。</p>
<a id="more"></a>



<p><img data-src="https://raw.githubusercontent.com/inlemontree/image/master/stadardBox.png"></p>
<p><img data-src="https://raw.githubusercontent.com/inlemontree/image/master/strangeBox.png"></p>
<h3 id="CSS-如何设置这两种盒模型？"><a href="#CSS-如何设置这两种盒模型？" class="headerlink" title="CSS 如何设置这两种盒模型？"></a>CSS 如何设置这两种盒模型？</h3><p>标准盒模型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">box-sizing: content-box;</span><br></pre></td></tr></table></figure>

<p>怪异盒模型：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span>;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>Vue中的computed和watch区别</title>
    <url>/2020/11/29/Vue%E4%B8%ADcomputed%E5%92%8Cwatch%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>以vue.js官方文档中获取全名的一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#demo&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;Foo&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;Bar&#x27;</span>,</span><br><span class="line">    fullName: <span class="string">&#x27;Foo Bar&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    firstName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.fullName = val + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    lastName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.fullName = <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#demo&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;Foo&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;Bar&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><p><code>computed：</code>是一个计算属性,类似于过滤器,对绑定到view的数据进行处理</p>
<p><code>watch：</code>是一个观察的动作</p>
<h2 id="2、区别"><a href="#2、区别" class="headerlink" title="2、区别"></a>2、区别</h2><h3 id="2-1、特性"><a href="#2-1、特性" class="headerlink" title="2.1、特性"></a>2.1、特性</h3><p><code>computed：</code></p>
<p>具有缓存性，页面重新渲染值不变化,计算属性会立即返回之前的计算结果，而不必再次执行函数</p>
<p><code>watch：</code></p>
<p>无缓存性，页面重新渲染时值不变化也会执行</p>
<h3 id="2-2、在写法上有没有什么区别？"><a href="#2-2、在写法上有没有什么区别？" class="headerlink" title="2.2、在写法上有没有什么区别？"></a>2.2、在写法上有没有什么区别？</h3><p>写法上有一个区别，<code>computed</code><strong>返回</strong>state处理后结果，<code>watch</code>是赋值行为，<strong>修改</strong>state。</p>
<ul>
<li>注意事项：<strong>不应该使用箭头函数来定义 watcher 函数</strong>，因为箭头函数没有 this，它的 this 会继承它的父级函数，但是它的父级函数是 window，导致箭头函数的 this 指向 window，而不是 Vue 实例</li>
</ul>
<h3 id="2-3、哪个更加底层？"><a href="#2-3、哪个更加底层？" class="headerlink" title="2.3、哪个更加底层？"></a>2.3、哪个更加底层？</h3><p><code>watch</code>和<code>computed</code>并没有哪个更底层，<code>watch</code>内部调用的是<code>vm.$watch</code>，它们的共同之处就是每个定义的属性都单独建立了一个<code>Watcher</code>对象。</p>
<h3 id="2-4、常见应用有什么？"><a href="#2-4、常见应用有什么？" class="headerlink" title="2.4、常见应用有什么？"></a>2.4、常见应用有什么？</h3><ul>
<li><p><code>computed</code>就是简化tempalte里面Mustache语法计算和处理props或$emit的传值.</p>
</li>
<li><p><code>watch</code>监听props，$emit或本组件的值执行异步操作。</p>
</li>
</ul>
<p><code>computed</code>的值在<code>getter</code>执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取<code>computed</code>的值时才会重新调用对应的<code>getter</code>来计算。<code>watch</code>在每次监听的值变化时，都会执行回调。其实从这一点来看，都是在依赖的值变化之后，去执行回调。很多功能本来就很多属性都可以用，只不过有更适合的。</p>
<p>如果一个值依赖多个属性（多对一），用<code>computed</code>肯定是更加方便的。如果一个值变化后会引起一系列操作，或者一个值变化会引起一系列值的变化（一对多），用<code>watch</code>更加方便一些。<br><code>watch</code>的回调里面会传入监听属性的新旧值，通过这两个值可以做一些特定的操作。<code>computed</code>通常就是简单的计算。</p>
<h2 id="3、我该选择哪个？"><a href="#3、我该选择哪个？" class="headerlink" title="3、我该选择哪个？"></a>3、我该选择哪个？</h2><p><code>computed</code>是用于定义<strong>基于数据之上的数据</strong>。</p>
<p>而<code>watch</code>是你想在<strong>某个数据变化时做一些事情</strong>，如果做的事情是更新其他数据，那其实与把这个要更新的数据项定义成<code>computed</code>是一样的，这个时候用computed更有可读性，虽然技术上讲<code>watch</code>也可以实现。</p>
<p>但你也可以在被watch的数据变化时做其他事情，比如调用一个方法，这个是<code>computed</code>做不到也不应该做的。</p>
<p>正如文档建议说 执行异步操作或开销较大的操作时使用<code>watch</code>。</p>
<h3 id="3-1、总结"><a href="#3-1、总结" class="headerlink" title="3.1、总结"></a>3.1、总结</h3><ol>
<li>简单且串行返回的，使用<code>computed</code>。</li>
<li>如果一个数据依赖于其他数据，那么把这个数据设计为<code>computed</code>的</li>
<li>如果你需要在某个数据变化时做一些事情，使用<code>watch</code>来观察这个数据变化。</li>
<li>执行异步操作不能串行返回结果，使用<code>watch</code>。</li>
<li>开销较大的操作，避免堵塞主线程，使用<code>watch</code>。</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>null与undefined</title>
    <url>/2020/11/02/null%E4%B8%8Eundefined/</url>
    <content><![CDATA[<h2 id="Undefined-类型"><a href="#Undefined-类型" class="headerlink" title="Undefined 类型"></a>Undefined 类型</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Undefined类型只有一个值，就是特殊的undefined，在两种情况下我们会得到undefined：</p>
<a id="more"></a>

<ol>
<li><p>声明了一个变量，但未对其初始化时，这个变量的值就是undefined。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data;</span><br><span class="line"><span class="built_in">console</span>.log(data === <span class="literal">undefined</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>那么我么是否可以显式地把一个变量初始化为undefined呢，答案是可以的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="literal">undefined</span>;</span><br><span class="line"><span class="built_in">console</span>.log(data === <span class="literal">undefined</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(data); <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">value = <span class="literal">undefined</span>;</span><br><span class="line"><span class="built_in">console</span>.log(data === <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>一般而言，我们不存在需要显式地把一个变量设置为undefined值的情况，因为对于未经初始化的值默认就会取得undefined值，而已经初始化的值再将其赋值为undefined来表示空值是没有意义且不可取的。况且字面值undefined的主要目的以用于比较，来区分空对象指针(后面我们会介绍到这指的就是null)与未经初始化的变量的情况。</p>
</li>
<li><p>对未定义的变量执行typeof操作符也会返回undefined</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//data变量未定义</span></span><br><span class="line"><span class="keyword">var</span> value;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> data); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> value); <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里我们没有使用<code>===</code>来判断，因为对于尚未声明过的变量，我们只能执行一项操作，即使用typeof操作符检测其数据类型，使用其他的操作都会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//data变量未定义</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data === <span class="literal">undefined</span>); <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>

<p>结果表明对未初始化和未声明的变量执行typeof操作符都返回了undefined值，这个结果有其逻辑上的合理性。因为虽然这两种变量从技术角度看有本质区别，但实际上无论对哪种变量也不可能执行真正的操作。</p>
</li>
</ol>
<p>还有其他几种情况也会返回undefined，比如一个函数如果没有使用return语句指定返回值，就会返回一个undefined值，或者调用函数时没有传参数值，参数同样也会被初始化为undefined值。这些都是属于上面两种情况在代码中的体现，这里就不单独解释了。</p>
<h3 id="全局属性-window-undefined"><a href="#全局属性-window-undefined" class="headerlink" title="全局属性 window.undefined"></a>全局属性 window.undefined</h3><p>从上面的例子我们可以看出，无论我们是否初始化过变量，都可以给变量赋值为undefined。其实这里用于赋值的undefined不是一个值，它是一个属性名，undefined是全局对象的一个属性，也就是说，它是全局作用域的一个变量，即<code>window.undefined</code>，而<code>window.undefined</code>这个属性的值才是前面所说的原始值undefined。<code>data = undefined;</code>这就相当于把一个变量<code>window.undefined</code>的值赋值给另一个变量<code>data</code>，这个值就是原始值undefined。其实在JavaScript代码中,我们看到的undefined大多数情况指的都是<code>window.undefined</code>(本篇文章中多数情况下也是，原始值undefined除外)，原始值undefined多数情况下只存在于文档或规范中,不存在于JavaScript代码中(具体可以理解为代码中参与判断、比较或赋值的都是<code>window.undefined</code>，而在控制台中输出，或函数中返回的则是原始值undefined)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.undefined); <span class="comment">//原始值undefined</span></span><br></pre></td></tr></table></figure>

<p>注意，在ES3之前其实是没有原始值undefined这个值的，第三版引入这个值，其实是为了正式区分空对象指针(后面我们会介绍到这指的就是null)与未经初始化的变量。在ES3中,<code>window.undefined</code>就是一个普通的属性，我们完全可以把它的值改为任何真值。但从ES5之后,<code>window.undefined</code>成了一个不可写,不可配置的数据属性,它的值永远是undefined。</p>
<h3 id="局部属性-undefined"><a href="#局部属性-undefined" class="headerlink" title="局部属性 undefined"></a>局部属性 undefined</h3><p>大家可能注意到了，上面我提到的是在大多数情况下undefined指的都是<code>window.undefined</code>，那还有什么其他情况吗？其实在ECMAScript中，undefined不是一个保留字，这意味着什么呢？也就是说我们可以将undefined作为一个局部变量来使用，就像局部作用域中任何其他普通变量一样，没有任何特殊性，我们可以对其赋予任何类型的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="literal">undefined</span> = <span class="string">&#x27;not is undefined&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="literal">undefined</span>); <span class="comment">//&quot;not is undefined&quot;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>) <span class="comment">// &quot;string&quot;</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>我们可以看到undefined的值和类型都已经改变，这样的做法是非常不友好的，这样会使我们的代码难以维护和排错。</p>
<h3 id="undefined-判断"><a href="#undefined-判断" class="headerlink" title="undefined 判断"></a>undefined 判断</h3><p>如何判断一个变量是否为undefined，这里有两种方法。</p>
<ol>
<li>使用严格相等符<code>===</code>或不相等操作符<code>!==</code>来决定一个变量是否拥有值，这里不使用标准相等操作符<code>==</code>,是因为标准相等符还会会检查变量是不是为null，但是严格相等操作符不会检查。null不等同于undefined，这点我们会在后面讲到。</li>
<li>使用typeof操作符，这种方式我们在上面已经使用过了，对未定义的变量检测时只能使用这种方式，要不然会出现报错。</li>
</ol>
<h2 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a>Null类型</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>Null类型是第二个只有一个值的数据类型，这个特殊的值就是null。值 null 是一个字面量，它不像undefined 是全局对象的一个属性。从逻辑角度来看，null值表示一个空对象指针，指示变量未指向任何对象。把 null 作为尚未创建的对象，也许更好理解。在 APIs 中，null 常在返回类型是对象，但没关联值的地方使用，就像下面一个例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;document.getElementById() 可以返回对拥有指定 ID 的第一个对象的引用</span><br><span class="line"></span><br><span class="line">var $container &#x3D; document.getElementById(&quot;container&quot;); &#x2F;&#x2F; 注意:container是不存在的</span><br><span class="line"></span><br><span class="line">console.log($container); &#x2F;&#x2F; null</span><br></pre></td></tr></table></figure>

<h3 id="typeof-null"><a href="#typeof-null" class="headerlink" title="typeof null"></a>typeof null</h3><p>当我们使用typeof操作符检测null值，我们理所应当地认为应该返”Null”类型呀，但是事实返回的类型却是”object”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var data &#x3D; null;</span><br><span class="line">console.log(typeof data); &#x2F;&#x2F; &quot;object&quot;</span><br></pre></td></tr></table></figure>

<p>是不是很奇怪？其实我们可以从两方面来理解这个结果</p>
<ul>
<li>一方面从逻辑角度来看，null值表示一个空对象指针，它代表的其实就是一个空对象，所以使用typeof操作符检测时返回”object”也是可以理解的。</li>
<li>另一方面，其实在JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null的类型标签也成为了 0，typeof null就错误的返回了”object”。在ES6中，当时曾经有提案为历史平凡, 将type null的值纠正为null, 但最后提案被拒了,所以还是保持”object”类型。</li>
</ul>
<h3 id="null-判断"><a href="#null-判断" class="headerlink" title="null 判断"></a>null 判断</h3><p>null的判断可以使用严格相等符<code>===</code>或不相等操作符<code>!==</code>判断，不使用标准相等符的原因是因为undefined会影响判断结果。和undefined不一样，不能使用typeof来判断一个值是否为null，原因上边已经讲了，使用typeof来检测null会返回”object”,这样的话我们是没办法判断的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(data === <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;data中没有保存对象引用！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="null-使用"><a href="#null-使用" class="headerlink" title="null 使用"></a>null 使用</h3><p>那么我们在什么情况下需要将变量赋值为null呢？这里我想到的有两种情况。</p>
<ul>
<li>如果定义的变量在将来用于保存对象，那么最好将该变量初始化为null，而不是其他值。换句话说，只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值，这样有助于进一步区分null和undefined。</li>
<li>当一个数据不再需要使用时，我们最好通过将其值设置为null来释放其引用，这个做法叫做解除引用。不过解除一个值的引用并不意味着自动回收改值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器在下次运行时将其回收。解除引用还有助于消除有可能出现的循环引用的情况。这一做法适用于大多数全局变量和全局对象的属性，局部变量会在它们离开执行环境时(函数执行完时)自动被解除引用。</li>
</ul>
<h2 id="undefined-与-null"><a href="#undefined-与-null" class="headerlink" title="undefined 与 null"></a>undefined 与 null</h2><p>实际上undefined值是派生自null值的，因此ECMA-262规定对它们的相等性测试要返回true:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="literal">undefined</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>因为使用的是标准相等符<code>==</code>,这个操作符出于目的会转换其操作数为相同类型后再做比较，如果我们使用严格相等符比较，我们会发现它们是不相等的，因为严格相等符不会进行类型转换，然而undefined与null属于不同的类型，所以不相等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> === <span class="literal">undefined</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>获取当前日期并以YYYY-MM-DD形式输出</title>
    <url>/2020/11/15/%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F%E5%B9%B6%E4%BB%A5YYYY-MM-DD%E5%BD%A2%E5%BC%8F%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h4 id="方法一、"><a href="#方法一、" class="headerlink" title="方法一、"></a>方法一、</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取当前时间，格式YYYY-MM-DD</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNowFormatDate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">var</span> seperator1 = <span class="string">&quot;-&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> year = date.getFullYear();</span><br><span class="line">  <span class="keyword">var</span> month = date.getMonth() + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> strDate = date.getDate();</span><br><span class="line">  <span class="keyword">if</span> (month &gt;= <span class="number">1</span> &amp;&amp; month &lt;= <span class="number">9</span>) &#123; month = <span class="string">&quot;0&quot;</span> + month; &#125;</span><br><span class="line">  <span class="keyword">if</span> (strDate &gt;= <span class="number">0</span> &amp;&amp; strDate &lt;= <span class="number">9</span>) &#123; strDate = <span class="string">&quot;0&quot;</span> + strDate; &#125;</span><br><span class="line">  <span class="keyword">var</span> currentdate = year + seperator1 + month + seperator1 + strDate;</span><br><span class="line">  <span class="keyword">return</span> currentdate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getNowFormatDate());</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="方法二、"><a href="#方法二、" class="headerlink" title="方法二、"></a>方法二、</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myDate = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> time = myDate.toLocaleDateString().split(<span class="string">&#x27;/&#x27;</span>).join(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(time);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>为什么0.1+0.2=0.30000000000000004？</title>
    <url>/2020/11/05/%E4%B8%BA%E4%BB%80%E4%B9%880.1+0.2%EF%BC%81=0.3/</url>
    <content><![CDATA[<p>​    首先看一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span>) <span class="comment">// 0.30000000000000004</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span>+<span class="number">0.2</span>!=<span class="number">0.3</span>) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="数字的存储和运算"><a href="#数字的存储和运算" class="headerlink" title="数字的存储和运算"></a>数字的存储和运算</h2><p>​    这其中涉及到JavaScript<code>数字运算的精度丢失</code>问题，要弄清这个问题的原因，首先我们需要了解下在计算机中数字是如何存储和运算的。在计算机中，数字无论是定点数还是浮点数都是以多位二进制的方式进行存储的。在JS中数字采用的IEEE 754的双精度标准进行存储，我们可以无需知道他的存储形式，只需要简单的理解成就是存储一个数值所使用的二进制位数比较多而已，这样得到的数会更加精确。</p>
<p>​    这里为了简单直观，我们使用定点数来说明问题。在定点数中，如果我们以8位二进制来存储数字。</p>
<p>对于整数来说，十进制的35会被存储为： <code>00100011</code> 其代表 <code>2^5 + 2^1 + 2^0</code>。<br>对于纯小数来说，十进制的0.375会被存储为： <code>0.011</code> 其代表 <code>1/2^2 + 1/2^3</code> = <code>1/4 + 1/8 = 0.375</code></p>
<p>​    而对于像0.1这样的数值用二进制表示你就会发现无法整除，最后算下来会是 <code>0.000110011....</code>由于存储空间有限，最后计算机会舍弃后面的数值，所以我们最后就只能得到一个近似值。在JS中采用的IEEE 754的双精度标准也是一样的道理，我们且不管这个标准下的存储方式跟定点数存储有何不同，单单在这一点上他们都是相同的，也就是存储空间有限，当出现这种无法整除的小数的时候就会取一个近似值，在js中如果这个近似值足够近似，那么js就会认为他就是那个值。</p>
<blockquote>
<p>关于浮点数值计算会产生舍入误差的问题，有一点需要明确：这是使用基于IEEE754数值的浮点计算的通病，ECMScript并非独此一家；使用其他相同数值格式的语言也存在这个问题。</p>
</blockquote>
<h2 id="浮点数值的最高精度是多少？"><a href="#浮点数值的最高精度是多少？" class="headerlink" title="浮点数值的最高精度是多少？"></a>浮点数值的最高精度是多少？</h2><p>​    答案是<strong>17</strong>位小数，因此在进行算数计算时其精确度远远不如整数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1000000000000001</span>)  </span><br><span class="line"><span class="comment">// 0.1000000000000001 (中间14个0，会打印出它本身)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0.10000000000000001</span>)  </span><br><span class="line"><span class="comment">// 0.1 (中间15个0，结果和我们预想的不一样，js会认为这两个值足够接近，所以会显示0.1)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span>) <span class="comment">// 0.30000000000000004 (中间15个0，同样与我们预想的不一样)</span></span><br></pre></td></tr></table></figure>

<p>​     所以我们现在应该可以理解，就是说由于0.1转换成二进制时是无限循环的，所以在计算机中0.1只能存储成一个近似值。另外说一句，除了那些能表示成 <code>x/2^n</code> 的数可以被精确表示以外，其余小数都是以近似值得方式存在的。</p>
<p>​    在0.1 + 0.2这个式子中，0.1和0.2都是近似表示的，在他们相加的时候，两个近似值进行了计算，导致最后得到的值是<code>0.30000000000000004</code>，此时对于JS来说，其不够近似于0.3，于是就出现了<code>0.1 + 0.2 != 0.3</code> 这个现象。<br>​    当然，也并非所有的近似值相加都得不到正确的结果。有时两个近似值进行计算的时候，得到的值是在JS的近似范围内的，于是就可以得到正确答案。</p>
<h2 id="怎么解决问题？"><a href="#怎么解决问题？" class="headerlink" title="怎么解决问题？"></a>怎么解决问题？</h2><p>​    那么最常用的方法就是将浮点数转化成整数计算。因为整数都是可以精确表示的。</p>
<p>比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对于<span class="number">0.1</span> + <span class="number">0.02</span> 我们需要转化成 ( <span class="number">10</span> + <span class="number">2</span> ) / <span class="number">1e2</span></span><br><span class="line">对于<span class="number">0.1</span> * <span class="number">0.02</span> 我们则转化成 <span class="number">1</span> * <span class="number">2</span> / <span class="number">1e3</span></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>如何水平居中盒子？</title>
    <url>/2020/10/01/%E5%A6%82%E4%BD%95%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%E7%9B%92%E5%AD%90%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><p><strong>-水平居中：给 div 设置一个宽度，然后添加 margin:0 auto 属性</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><strong>-水平居中，利用 text-align:center 实现</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>-让绝对定位的 div 居中</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink; <span class="comment">/*方便看效果*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><p><strong>-水平垂直居中一</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*确定容器的宽高宽500高300的层设置层的外边距div&#123;*/</span></span><br><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;<span class="comment">/*绝对定位*/</span></span><br><span class="line"><span class="selector-tag">width</span>: 500<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">height</span>: 300<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">top</span>: 50%;</span><br><span class="line"><span class="selector-tag">left</span>: 50%;</span><br><span class="line"><span class="selector-tag">margin</span>: <span class="selector-tag">-150px00-250px</span>;<span class="comment">/*外边距为自身宽高的一半*/</span></span><br><span class="line"><span class="selector-tag">background-color</span>: <span class="selector-tag">pink</span>;<span class="comment">/*方便看效果*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>-水平垂直居中二</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*未知容器的宽高，利用`transform`属性*/</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute; <span class="comment">/*相对定位或绝对定位均可*/</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">  <span class="attribute">background-color</span>: pink; <span class="comment">/*方便看效果*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>-水平垂直居中三</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*利用flex布局实际使用时应考虑兼容性*/</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center; <span class="comment">/*垂直居中*/</span></span><br><span class="line">  <span class="attribute">justify-content</span>: center; <span class="comment">/*水平居中*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.containerdiv</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink; <span class="comment">/*方便看效果*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>-水平垂直居中四</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*利用text-align:center和vertical-align:middle属性*/</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">  <span class="attribute">white-space</span>: normal;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>一般常见的几种居中的方法有：</p>
<p>对于宽高固定的元素</p>
<p>（1）我们可以利用margin:0 auto来实现元素的水平居中。</p>
<p>（2）利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水<br>平和垂直方向上的居中。</p>
<p>（3）利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素<br>的中心点到页面的中心。</p>
<p>（4）利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素<br>的中心点到页面的中心。</p>
<p>（5）使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对<br>齐，然后它的子元素也可以实现垂直和水平的居中。</p>
<p>对于宽高不定的元素，上面的后面两种方法，可以实现元素的垂直和水平的居中。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>获取文件名后缀</title>
    <url>/2020/11/10/%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%90%8D%E5%90%8E%E7%BC%80/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> filename = file;</span><br><span class="line">  <span class="keyword">var</span> index1 = filename.lastIndexOf(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> index2 = filename.length;</span><br><span class="line">  <span class="keyword">var</span> type = filename.substring(index1, index2);</span><br><span class="line">  <span class="keyword">return</span> type;</span><br><span class="line">  <span class="built_in">console</span>.log(type);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getType(<span class="string">&#x27;test.exe&#x27;</span>));</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fileName = <span class="string">&quot;www.aaa.com/index.html&quot;</span>;</span><br><span class="line"></span><br><span class="line">方法<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fileExtension = fileName.substring(fileName.lastIndexOf(<span class="string">&#x27;.&#x27;</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方法<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fileExtension =fileName.substring(fileName.length-<span class="number">3</span>,fileName.length).toLowerCase();</span><br><span class="line"></span><br><span class="line">方法<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fileExtension = fileName.split(<span class="string">&#x27;.&#x27;</span>).pop().toLowerCase();</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFileType</span>(<span class="params">filePath</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> startIndex = filePath.lastIndexOf(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(startIndex != -<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> filePath.substring(startIndex+<span class="number">1</span>, filePath.length).toLowerCase();</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>面试必问之原型</title>
    <url>/2020/12/01/%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE%E4%B9%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<p>关于原型和原型链这一块本人也是理解了一段时间才有了初步的认识，理解障碍第一就是一些专有名词的混淆，比如：<code>prototype</code> 和 <code>__proto__</code>过于相似不好去记忆，下面是自己的一些总结。</p>
<a id="more"></a>
<h2 id="一、原型-prototype-和-proto"><a href="#一、原型-prototype-和-proto" class="headerlink" title="一、原型 prototype 和 __proto__"></a>一、原型 <code>prototype</code> 和 <code>__proto__</code></h2><ul>
<li><p>每个对象都有一个<code>__proto__</code>属性，并且指向它的<code>prototype</code>原型对象</p>
</li>
<li><p>每个构造函数都有一个<code>prototype</code>原型对象</p>
</li>
<li><ul>
<li><code>prototype</code>原型对象里的<code>constructor</code>指向构造函数本身</li>
</ul>
</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/inlemontree/image/master/116c3514022e6e0a29cfe3aed5e4720.jpg"></p>
<h3 id="你可能会问prototype-和-proto-有什么用呢？"><a href="#你可能会问prototype-和-proto-有什么用呢？" class="headerlink" title="你可能会问prototype 和 __proto__有什么用呢？"></a>你可能会问<code>prototype</code> 和 <code>__proto__</code>有什么用呢？</h3><p>实例对象的<code>__proto__</code>指向构造函数的<code>prototype</code>，从而实现继承。</p>
<p><code>prototype</code>对象相当于特定类型所有实例对象都可以访问的公共容器</p>
<h2 id="js-获取原型的方法？"><a href="#js-获取原型的方法？" class="headerlink" title="js 获取原型的方法？"></a>js 获取原型的方法？</h2><ul>
<li>p.__proto__</li>
<li>p.constructor.prototype</li>
<li>Object.getPrototypeOf(p)</li>
</ul>
<h2 id="他们的特点是什么"><a href="#他们的特点是什么" class="headerlink" title="他们的特点是什么"></a>他们的特点是什么</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对</span><br><span class="line">象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部</span><br><span class="line">将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说我们</span><br><span class="line">是不应该能够获取到这个值的，但是现在浏览器中都实现了 __proto__ 属性来让我们访问这个属性，但是我们最好不要使用这</span><br><span class="line">个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，我们可以通过这个方法来获取对</span><br><span class="line">象的原型。</span><br><span class="line"></span><br><span class="line">当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又</span><br><span class="line">会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就</span><br><span class="line">是我们新建的对象为什么能够使用 toString() 等方法的原因。</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line"></span><br><span class="line">JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与</span><br><span class="line">之相关的对象也会继承这一改变。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
</search>
