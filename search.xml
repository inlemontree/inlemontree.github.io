<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Vue中的computed和watch区别</title>
    <url>/2020/11/29/Vue%E4%B8%ADcomputed%E5%92%8Cwatch%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>以vue.js官方文档中获取全名的一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#demo&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;Foo&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;Bar&#x27;</span>,</span><br><span class="line">    fullName: <span class="string">&#x27;Foo Bar&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    firstName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.fullName = val + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    lastName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.fullName = <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#demo&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;Foo&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;Bar&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><p><code>computed：</code>是一个计算属性,类似于过滤器,对绑定到view的数据进行处理</p>
<p><code>watch：</code>是一个观察的动作</p>
<h2 id="2、区别"><a href="#2、区别" class="headerlink" title="2、区别"></a>2、区别</h2><h3 id="2-1、特性"><a href="#2-1、特性" class="headerlink" title="2.1、特性"></a>2.1、特性</h3><p><code>computed：</code></p>
<p>具有缓存性，页面重新渲染值不变化,计算属性会立即返回之前的计算结果，而不必再次执行函数</p>
<p><code>watch：</code></p>
<p>无缓存性，页面重新渲染时值不变化也会执行</p>
<h3 id="2-2、在写法上有没有什么区别？"><a href="#2-2、在写法上有没有什么区别？" class="headerlink" title="2.2、在写法上有没有什么区别？"></a>2.2、在写法上有没有什么区别？</h3><p>写法上有一个区别，<code>computed</code><strong>返回</strong>state处理后结果，<code>watch</code>是赋值行为，<strong>修改</strong>state。</p>
<ul>
<li>注意事项：<strong>不应该使用箭头函数来定义 watcher 函数</strong>，因为箭头函数没有 this，它的 this 会继承它的父级函数，但是它的父级函数是 window，导致箭头函数的 this 指向 window，而不是 Vue 实例</li>
</ul>
<h3 id="2-3、哪个更加底层？"><a href="#2-3、哪个更加底层？" class="headerlink" title="2.3、哪个更加底层？"></a>2.3、哪个更加底层？</h3><p><code>watch</code>和<code>computed</code>并没有哪个更底层，<code>watch</code>内部调用的是<code>vm.$watch</code>，它们的共同之处就是每个定义的属性都单独建立了一个<code>Watcher</code>对象。</p>
<h3 id="2-4、常见应用有什么？"><a href="#2-4、常见应用有什么？" class="headerlink" title="2.4、常见应用有什么？"></a>2.4、常见应用有什么？</h3><ul>
<li><p><code>computed</code>就是简化tempalte里面Mustache语法计算和处理props或$emit的传值.</p>
</li>
<li><p><code>watch</code>监听props，$emit或本组件的值执行异步操作。</p>
</li>
</ul>
<p><code>computed</code>的值在<code>getter</code>执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取<code>computed</code>的值时才会重新调用对应的<code>getter</code>来计算。<code>watch</code>在每次监听的值变化时，都会执行回调。其实从这一点来看，都是在依赖的值变化之后，去执行回调。很多功能本来就很多属性都可以用，只不过有更适合的。</p>
<p>如果一个值依赖多个属性（多对一），用<code>computed</code>肯定是更加方便的。如果一个值变化后会引起一系列操作，或者一个值变化会引起一系列值的变化（一对多），用<code>watch</code>更加方便一些。<br><code>watch</code>的回调里面会传入监听属性的新旧值，通过这两个值可以做一些特定的操作。<code>computed</code>通常就是简单的计算。</p>
<h2 id="3、我该选择哪个？"><a href="#3、我该选择哪个？" class="headerlink" title="3、我该选择哪个？"></a>3、我该选择哪个？</h2><p><code>computed</code>是用于定义<strong>基于数据之上的数据</strong>。</p>
<p>而<code>watch</code>是你想在<strong>某个数据变化时做一些事情</strong>，如果做的事情是更新其他数据，那其实与把这个要更新的数据项定义成<code>computed</code>是一样的，这个时候用computed更有可读性，虽然技术上讲<code>watch</code>也可以实现。</p>
<p>但你也可以在被watch的数据变化时做其他事情，比如调用一个方法，这个是<code>computed</code>做不到也不应该做的。</p>
<p>正如文档建议说 执行异步操作或开销较大的操作时使用<code>watch</code>。</p>
<h3 id="3-1、总结"><a href="#3-1、总结" class="headerlink" title="3.1、总结"></a>3.1、总结</h3><ol>
<li>简单且串行返回的，使用<code>computed</code>。</li>
<li>如果一个数据依赖于其他数据，那么把这个数据设计为<code>computed</code>的</li>
<li>如果你需要在某个数据变化时做一些事情，使用<code>watch</code>来观察这个数据变化。</li>
<li>执行异步操作不能串行返回结果，使用<code>watch</code>。</li>
<li>开销较大的操作，避免堵塞主线程，使用<code>watch</code>。</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>为什么0.1+0.2=0.30000000000000004？</title>
    <url>/2020/12/01/%E4%B8%BA%E4%BB%80%E4%B9%880.1+0.2%EF%BC%81=0.3/</url>
    <content><![CDATA[<p>​    首先看一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span>) <span class="comment">// 0.30000000000000004</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span>+<span class="number">0.2</span>!=<span class="number">0.3</span>) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="数字的存储和运算"><a href="#数字的存储和运算" class="headerlink" title="数字的存储和运算"></a>数字的存储和运算</h2><p>​    这其中涉及到JavaScript<code>数字运算的精度丢失</code>问题，要弄清这个问题的原因，首先我们需要了解下在计算机中数字是如何存储和运算的。在计算机中，数字无论是定点数还是浮点数都是以多位二进制的方式进行存储的。在JS中数字采用的IEEE 754的双精度标准进行存储，我们可以无需知道他的存储形式，只需要简单的理解成就是存储一个数值所使用的二进制位数比较多而已，这样得到的数会更加精确。</p>
<p>​    这里为了简单直观，我们使用定点数来说明问题。在定点数中，如果我们以8位二进制来存储数字。</p>
<p>对于整数来说，十进制的35会被存储为： <code>00100011</code> 其代表 <code>2^5 + 2^1 + 2^0</code>。<br>对于纯小数来说，十进制的0.375会被存储为： <code>0.011</code> 其代表 <code>1/2^2 + 1/2^3</code> = <code>1/4 + 1/8 = 0.375</code></p>
<p>​    而对于像0.1这样的数值用二进制表示你就会发现无法整除，最后算下来会是 <code>0.000110011....</code>由于存储空间有限，最后计算机会舍弃后面的数值，所以我们最后就只能得到一个近似值。在JS中采用的IEEE 754的双精度标准也是一样的道理，我们且不管这个标准下的存储方式跟定点数存储有何不同，单单在这一点上他们都是相同的，也就是存储空间有限，当出现这种无法整除的小数的时候就会取一个近似值，在js中如果这个近似值足够近似，那么js就会认为他就是那个值。</p>
<blockquote>
<p>关于浮点数值计算会产生舍入误差的问题，有一点需要明确：这是使用基于IEEE754数值的浮点计算的通病，ECMScript并非独此一家；使用其他相同数值格式的语言也存在这个问题。</p>
</blockquote>
<h2 id="浮点数值的最高精度是多少？"><a href="#浮点数值的最高精度是多少？" class="headerlink" title="浮点数值的最高精度是多少？"></a>浮点数值的最高精度是多少？</h2><p>​    答案是<strong>17</strong>位小数，因此在进行算数计算时其精确度远远不如整数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1000000000000001</span>)  </span><br><span class="line"><span class="comment">// 0.1000000000000001 (中间14个0，会打印出它本身)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0.10000000000000001</span>)  </span><br><span class="line"><span class="comment">// 0.1 (中间15个0，结果和我们预想的不一样，js会认为这两个值足够接近，所以会显示0.1)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span>) <span class="comment">// 0.30000000000000004 (中间15个0，同样与我们预想的不一样)</span></span><br></pre></td></tr></table></figure>

<p>​     所以我们现在应该可以理解，就是说由于0.1转换成二进制时是无限循环的，所以在计算机中0.1只能存储成一个近似值。另外说一句，除了那些能表示成 <code>x/2^n</code> 的数可以被精确表示以外，其余小数都是以近似值得方式存在的。</p>
<p>​    在0.1 + 0.2这个式子中，0.1和0.2都是近似表示的，在他们相加的时候，两个近似值进行了计算，导致最后得到的值是<code>0.30000000000000004</code>，此时对于JS来说，其不够近似于0.3，于是就出现了<code>0.1 + 0.2 != 0.3</code> 这个现象。<br>​    当然，也并非所有的近似值相加都得不到正确的结果。有时两个近似值进行计算的时候，得到的值是在JS的近似范围内的，于是就可以得到正确答案。</p>
<h2 id="怎么解决问题？"><a href="#怎么解决问题？" class="headerlink" title="怎么解决问题？"></a>怎么解决问题？</h2><p>​    那么最常用的方法就是将浮点数转化成整数计算。因为整数都是可以精确表示的。</p>
<p>比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对于<span class="number">0.1</span> + <span class="number">0.02</span> 我们需要转化成 ( <span class="number">10</span> + <span class="number">2</span> ) / <span class="number">1e2</span></span><br><span class="line">对于<span class="number">0.1</span> * <span class="number">0.02</span> 我们则转化成 <span class="number">1</span> * <span class="number">2</span> / <span class="number">1e3</span></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>获取当前日期并以YYYY-MM-DD形式输出</title>
    <url>/2020/11/28/%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F%E5%B9%B6%E4%BB%A5YYYY-MM-DD%E5%BD%A2%E5%BC%8F%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h4 id="方法一、"><a href="#方法一、" class="headerlink" title="方法一、"></a>方法一、</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取当前时间，格式YYYY-MM-DD</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNowFormatDate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">var</span> seperator1 = <span class="string">&quot;-&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> year = date.getFullYear();</span><br><span class="line">  <span class="keyword">var</span> month = date.getMonth() + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> strDate = date.getDate();</span><br><span class="line">  <span class="keyword">if</span> (month &gt;= <span class="number">1</span> &amp;&amp; month &lt;= <span class="number">9</span>) &#123; month = <span class="string">&quot;0&quot;</span> + month; &#125;</span><br><span class="line">  <span class="keyword">if</span> (strDate &gt;= <span class="number">0</span> &amp;&amp; strDate &lt;= <span class="number">9</span>) &#123; strDate = <span class="string">&quot;0&quot;</span> + strDate; &#125;</span><br><span class="line">  <span class="keyword">var</span> currentdate = year + seperator1 + month + seperator1 + strDate;</span><br><span class="line">  <span class="keyword">return</span> currentdate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getNowFormatDate());</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="方法二、"><a href="#方法二、" class="headerlink" title="方法二、"></a>方法二、</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myDate = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> time = myDate.toLocaleDateString().split(<span class="string">&#x27;/&#x27;</span>).join(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(time);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>获取文件名后缀</title>
    <url>/2020/12/01/%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%90%8D%E5%90%8E%E7%BC%80/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> filename = file;</span><br><span class="line">  <span class="keyword">var</span> index1 = filename.lastIndexOf(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> index2 = filename.length;</span><br><span class="line">  <span class="keyword">var</span> type = filename.substring(index1, index2);</span><br><span class="line">  <span class="keyword">return</span> type;</span><br><span class="line">  <span class="built_in">console</span>.log(type);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getType(<span class="string">&#x27;test.exe&#x27;</span>));</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fileName = <span class="string">&quot;www.aaa.com/index.html&quot;</span>;</span><br><span class="line"></span><br><span class="line">方法<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fileExtension = fileName.substring(fileName.lastIndexOf(<span class="string">&#x27;.&#x27;</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方法<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fileExtension =fileName.substring(fileName.length-<span class="number">3</span>,fileName.length).toLowerCase();</span><br><span class="line"></span><br><span class="line">方法<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fileExtension = fileName.split(<span class="string">&#x27;.&#x27;</span>).pop().toLowerCase();</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFileType</span>(<span class="params">filePath</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> startIndex = filePath.lastIndexOf(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(startIndex != -<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> filePath.substring(startIndex+<span class="number">1</span>, filePath.length).toLowerCase();</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
</search>
